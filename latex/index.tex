\hypertarget{index_intro_sec}{}\section{Introduction}\label{index_intro_sec}
Allocate and free dynamic memory\hypertarget{index_descr_sec}{}\section{Description}\label{index_descr_sec}
\hypertarget{index_malloc}{}\subsection{Malloc}\label{index_malloc}
The \hyperlink{malloc_8c_a7ac38fce3243a7dcf448301ee9ffd392}{malloc()} function allocates size bytes and returns a pointer to the allocated memory. The memory is not initialized. If size is 0, then \hyperlink{malloc_8c_a7ac38fce3243a7dcf448301ee9ffd392}{malloc()} returns either N\+U\+LL, or a unique pointer value that can later be successfully passed to \hyperlink{free_8c_ac27a03e54e8a0e720ad2cfb00cdc7511}{free()}.\hypertarget{index_free}{}\subsection{Free}\label{index_free}
The \hyperlink{free_8c_ac27a03e54e8a0e720ad2cfb00cdc7511}{free()} function frees the memory space pointed to by ptr, which must have been returned by a previous call to \hyperlink{malloc_8c_a7ac38fce3243a7dcf448301ee9ffd392}{malloc()}, \hyperlink{calloc_8c_a62b7798461bd461da64c5f9d35feddf7}{calloc()} or \hyperlink{realloc_8c_a1a6b5e8d2f1c37e5b43e4345586075be}{realloc()}. Otherwise, or if free(ptr) has already been called before, undefined behavior occurs. If ptr is N\+U\+LL, no operation is performed.\hypertarget{index_calloc}{}\subsection{Calloc}\label{index_calloc}
The \hyperlink{calloc_8c_a62b7798461bd461da64c5f9d35feddf7}{calloc()} function allocates memory for an array of nmemb elements of size bytes each and returns a pointer to the allocated memory. The memory is set to zero. If nmemb or size is 0, then \hyperlink{calloc_8c_a62b7798461bd461da64c5f9d35feddf7}{calloc()} returns either N\+U\+LL, or a unique pointer value that can later be successfully passed to \hyperlink{free_8c_ac27a03e54e8a0e720ad2cfb00cdc7511}{free()}.\hypertarget{index_realloc}{}\subsection{Realloc}\label{index_realloc}
The \hyperlink{realloc_8c_a1a6b5e8d2f1c37e5b43e4345586075be}{realloc()} function changes the size of the memory block pointed to by ptr to size bytes. The contents will be unchanged in the range from the start of the region up to the minimum of the old and new sizes. If the new size is larger than the old size, the added memory will not be initialized. If ptr is N\+U\+LL, then the call is equivalent to malloc(size), for all values of size; if size is equal to zero, and ptr is not N\+U\+LL, then the call is equivalent to free(ptr). Unless ptr is N\+U\+LL, it must have been returned by an earlier call to \hyperlink{malloc_8c_a7ac38fce3243a7dcf448301ee9ffd392}{malloc()}, \hyperlink{calloc_8c_a62b7798461bd461da64c5f9d35feddf7}{calloc()} or \hyperlink{realloc_8c_a1a6b5e8d2f1c37e5b43e4345586075be}{realloc()}. If the area pointed to was moved, a free(ptr) is done.\hypertarget{index_ret_sec}{}\section{Return Value}\label{index_ret_sec}
\hypertarget{index_malloc}{}\subsection{Malloc}\label{index_malloc}
The \hyperlink{malloc_8c_a7ac38fce3243a7dcf448301ee9ffd392}{malloc()} and \hyperlink{calloc_8c_a62b7798461bd461da64c5f9d35feddf7}{calloc()} functions return a pointer to the allocated memory that is suitably aligned for any kind of variable. On error, these functions return N\+U\+LL. N\+U\+LL may also be returned by a successful call to \hyperlink{malloc_8c_a7ac38fce3243a7dcf448301ee9ffd392}{malloc()} with a size of zero, or by a successful call to \hyperlink{calloc_8c_a62b7798461bd461da64c5f9d35feddf7}{calloc()} with nmemb or size equal to zero.\hypertarget{index_free}{}\subsection{Free}\label{index_free}
The \hyperlink{free_8c_ac27a03e54e8a0e720ad2cfb00cdc7511}{free()} function returns no value.\hypertarget{index_realloc}{}\subsection{Realloc}\label{index_realloc}
The \hyperlink{realloc_8c_a1a6b5e8d2f1c37e5b43e4345586075be}{realloc()} function returns a pointer to the newly allocated memory, which is suitably aligned for any kind of variable and may be different from ptr, or N\+U\+LL if the request fails. If size was equal to 0, either N\+U\+LL or a pointer suitable to be passed to \hyperlink{free_8c_ac27a03e54e8a0e720ad2cfb00cdc7511}{free()} is returned. If \hyperlink{realloc_8c_a1a6b5e8d2f1c37e5b43e4345586075be}{realloc()} fails the original block is left untouched; it is not freed or moved. 